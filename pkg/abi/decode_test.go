package abi_test

import (
	"bytes"
	"testing"

	"github.com/greymass/go-eosio/internal/assert"
	"github.com/greymass/go-eosio/pkg/abi"
)

func testDecoder(data []byte) *abi.Decoder {
	return abi.NewDecoder(bytes.NewReader(data), func(dec *abi.Decoder, v interface{}) (done bool, err error) {
		return false, nil
	})
}

func unmarshal(data []byte, v interface{}) error {
	return testDecoder(data).Decode(v)
}

// struct

type testStruct struct {
	Answer uint64
}

type testNestedStruct struct {
	Question int32
	Response testStruct
}

type testRecursiveStruct struct {
	Answer uint64
	Other  *testRecursiveStruct `eosio:"optional"`
}

var structData = []byte{
	0xff, 0xff, 0xff, 0xff, // int32: -1
	0x2a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // uint64: 42
}

var recursiveStructData = []byte{
	0x2a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // uint64: 42
	0x01,                                           // optional
	0xb2, 0xc9, 0x9e, 0xb3, 0x3c, 0x36, 0xe3, 0x05, // uint64: 424242424242424242
	0x01,                                           // optional
	0x1c, 0xd7, 0xe8, 0x08, 0x01, 0x00, 0x00, 0x00, // uint64: 4444444444
	0x00, // optional (empty)
}

func TestStruct(t *testing.T) {
	var s testNestedStruct
	err := unmarshal(structData, &s)
	assert.NoError(t, err)
	assert.Equal(t, s.Question, int32(-1))
	assert.Equal(t, s.Response.Answer, uint64(42))
}

func TestStructRecursive(t *testing.T) {
	var s testRecursiveStruct
	err := unmarshal(recursiveStructData, &s)
	assert.NoError(t, err)
	assert.Equal(t, s.Answer, uint64(42))
	assert.NotNil(t, s.Other)
	assert.Equal(t, s.Other.Answer, uint64(424242424242424242))
	assert.NotNil(t, s.Other.Other)
	assert.Equal(t, s.Other.Other.Answer, uint64(4444444444))
}

type testBigStruct struct {
	A int32
	B uint64
	C string
	D []byte
	E testNestedStruct
	F []testNestedStruct
}

var bigStructData = []byte{
	0xb2, 0x9e, 0x43, 0xff, // int32: -12345678
	0x2a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // uint64: 42
	0x12, 0x67, 0x72, 0x65, 0x79, 0x6d, 0x61, 0x73, 0x73, 0x20, 0x69, 0x73, 0x20, 0x66, 0x61, 0x73, 0x74, 0x65, 0x72, // string: "greymass is faster"
	// 256 random bytes
	0x80, 0x02, 0x67, 0x97, 0x20, 0x88, 0x47, 0x8a, 0xe7, 0x2c, 0x87, 0x12, 0x04, 0x48, 0xf8, 0xb5, 0xea, 0x02, 0xbd,
	0xa2, 0x5e, 0x77, 0x09, 0x3c, 0x71, 0x21, 0xc2, 0x30, 0x9a, 0xa9, 0x2f, 0x57, 0x96, 0xe6, 0x03, 0x5c, 0x1d, 0xb8,
	0xed, 0x1a, 0xcf, 0xe9, 0xa5, 0x59, 0x6a, 0x07, 0x2c, 0x25, 0x3b, 0xed, 0x66, 0x70, 0xe2, 0x02, 0x70, 0xe9, 0x41,
	0xd2, 0x5f, 0x60, 0x7a, 0x79, 0xd0, 0xb9, 0xf0, 0x29, 0x6b, 0x0f, 0xf3, 0x0b, 0x81, 0x91, 0x29, 0x71, 0xd7, 0xb0,
	0xac, 0x7b, 0x34, 0x89, 0x61, 0xf8, 0xc5, 0x71, 0xcc, 0xee, 0x5b, 0x13, 0x6b, 0x61, 0xc2, 0x31, 0xd8, 0xbb, 0x0d,
	0xf5, 0xa8, 0x8c, 0x22, 0x24, 0xef, 0xb5, 0x1e, 0xac, 0x76, 0xfb, 0x3a, 0xea, 0x5f, 0x0a, 0x66, 0x74, 0xae, 0x12,
	0xb5, 0xf0, 0xb1, 0xd9, 0xf6, 0x80, 0x29, 0x92, 0xfc, 0x5a, 0x0c, 0xfa, 0x02, 0xd2, 0xd0, 0x98, 0xeb, 0x22, 0xa6,
	0xeb, 0xa5, 0xaf, 0x37, 0xce, 0x3e, 0x5d, 0xfe, 0x0a, 0x6b, 0xf0, 0xa6, 0xe5, 0x6c, 0xcc, 0x05, 0xa6, 0xb2, 0x94,
	0xc4, 0x0c, 0xb8, 0x8a, 0x53, 0xe5, 0x80, 0xbf, 0x9e, 0x1f, 0xb6, 0xa7, 0x06, 0x72, 0x79, 0x52, 0xfd, 0xfe, 0xd6,
	0xd1, 0x1b, 0x8b, 0x40, 0x35, 0x26, 0x13, 0x2a, 0xb6, 0x56, 0xe6, 0xf6, 0x1e, 0x9f, 0x7a, 0x96, 0xb0, 0x8d, 0xb9,
	0x11, 0x80, 0x0d, 0x2d, 0xa3, 0xa6, 0x3b, 0xed, 0xbe, 0x5f, 0xf6, 0xbf, 0x02, 0x8f, 0xa0, 0xd1, 0x85, 0x5a, 0x97,
	0x4a, 0x75, 0xed, 0x72, 0x3a, 0xd4, 0xb9, 0x6b, 0x60, 0x00, 0x9d, 0x75, 0xef, 0x9d, 0x4d, 0x54, 0x2b, 0xdc, 0x7f,
	0x22, 0x6f, 0xe4, 0x8e, 0xc8, 0x8d, 0xb2, 0xd7, 0x00, 0x90, 0x03, 0xaa, 0x4c, 0xfa, 0x82, 0xef, 0xb9, 0xd2, 0x81,
	0x66, 0x40, 0xf0, 0xc8, 0x52, 0x66, 0x23, 0x52, 0x89, 0x79, 0x59,
	// nested struct
	0xff, 0xff, 0xff, 0xff, // int32: -1
	0x2a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // uint64: 42
	// 5x nested struct
	0x05,
	0xff, 0xff, 0xff, 0xff, // int32: -1
	0x2a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // uint64: 42
	0xff, 0xff, 0xff, 0xff, // int32: -1
	0x2a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // uint64: 42
	0xff, 0xff, 0xff, 0xff, // int32: -1
	0x2a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // uint64: 42
	0xff, 0xff, 0xff, 0xff, // int32: -1
	0x2a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // uint64: 42
	0xff, 0xff, 0xff, 0xff, // int32: -1
	0x2a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // uint64: 42
}

var testBigStructValue = testBigStruct{
	A: -12345678,
	B: 42,
	C: "greymass is faster",
	D: []byte{
		0x67, 0x97, 0x20, 0x88, 0x47, 0x8a, 0xe7, 0x2c, 0x87, 0x12, 0x04, 0x48,
		0xf8, 0xb5, 0xea, 0x02, 0xbd, 0xa2, 0x5e, 0x77, 0x09, 0x3c, 0x71, 0x21, 0xc2,
		0x30, 0x9a, 0xa9, 0x2f, 0x57, 0x96, 0xe6, 0x03, 0x5c, 0x1d, 0xb8, 0xed, 0x1a,
		0xcf, 0xe9, 0xa5, 0x59, 0x6a, 0x07, 0x2c, 0x25, 0x3b, 0xed, 0x66, 0x70, 0xe2,
		0x02, 0x70, 0xe9, 0x41, 0xd2, 0x5f, 0x60, 0x7a, 0x79, 0xd0, 0xb9, 0xf0, 0x29,
		0x6b, 0x0f, 0xf3, 0x0b, 0x81, 0x91, 0x29, 0x71, 0xd7, 0xb0, 0xac, 0x7b, 0x34,
		0x89, 0x61, 0xf8, 0xc5, 0x71, 0xcc, 0xee, 0x5b, 0x13, 0x6b, 0x61, 0xc2, 0x31,
		0xd8, 0xbb, 0x0d, 0xf5, 0xa8, 0x8c, 0x22, 0x24, 0xef, 0xb5, 0x1e, 0xac, 0x76,
		0xfb, 0x3a, 0xea, 0x5f, 0x0a, 0x66, 0x74, 0xae, 0x12, 0xb5, 0xf0, 0xb1, 0xd9,
		0xf6, 0x80, 0x29, 0x92, 0xfc, 0x5a, 0x0c, 0xfa, 0x02, 0xd2, 0xd0, 0x98, 0xeb,
		0x22, 0xa6, 0xeb, 0xa5, 0xaf, 0x37, 0xce, 0x3e, 0x5d, 0xfe, 0x0a, 0x6b, 0xf0,
		0xa6, 0xe5, 0x6c, 0xcc, 0x05, 0xa6, 0xb2, 0x94, 0xc4, 0x0c, 0xb8, 0x8a, 0x53,
		0xe5, 0x80, 0xbf, 0x9e, 0x1f, 0xb6, 0xa7, 0x06, 0x72, 0x79, 0x52, 0xfd, 0xfe,
		0xd6, 0xd1, 0x1b, 0x8b, 0x40, 0x35, 0x26, 0x13, 0x2a, 0xb6, 0x56, 0xe6, 0xf6,
		0x1e, 0x9f, 0x7a, 0x96, 0xb0, 0x8d, 0xb9, 0x11, 0x80, 0x0d, 0x2d, 0xa3, 0xa6,
		0x3b, 0xed, 0xbe, 0x5f, 0xf6, 0xbf, 0x02, 0x8f, 0xa0, 0xd1, 0x85, 0x5a, 0x97,
		0x4a, 0x75, 0xed, 0x72, 0x3a, 0xd4, 0xb9, 0x6b, 0x60, 0x00, 0x9d, 0x75, 0xef,
		0x9d, 0x4d, 0x54, 0x2b, 0xdc, 0x7f, 0x22, 0x6f, 0xe4, 0x8e, 0xc8, 0x8d, 0xb2,
		0xd7, 0x00, 0x90, 0x03, 0xaa, 0x4c, 0xfa, 0x82, 0xef, 0xb9, 0xd2, 0x81, 0x66,
		0x40, 0xf0, 0xc8, 0x52, 0x66, 0x23, 0x52, 0x89, 0x79, 0x59,
	},
	E: testNestedStruct{
		Question: -1,
		Response: testStruct{
			Answer: 42,
		},
	},
	F: []testNestedStruct{
		{
			Question: -1,
			Response: testStruct{
				Answer: 42,
			},
		},
		{
			Question: -1,
			Response: testStruct{
				Answer: 42,
			},
		},
		{
			Question: -1,
			Response: testStruct{
				Answer: 42,
			},
		},
		{
			Question: -1,
			Response: testStruct{
				Answer: 42,
			},
		},
		{
			Question: -1,
			Response: testStruct{
				Answer: 42,
			},
		},
	},
}

func TestStructBig(t *testing.T) {
	var s testBigStruct
	err := unmarshal(bigStructData, &s)
	assert.NoError(t, err)
	assert.Equal(t, testBigStructValue, s)
}

// variant

type testVariant struct {
	A *uint64
	B *string
}

var variantBytes1 = []byte{
	// variant index byte: 0
	0x00,
	// name: "teamgreymass"
	0x80, 0xb1, 0x91, 0x5e, 0x5d, 0x26, 0x8d, 0xca,
}

var variantBytes2 = []byte{
	// variant index byte: 1
	0x01,
	// string len varuint32: 11
	0x0b,
	// string utf8 bytes: "hello world"
	0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x20, 0x77, 0x6f, 0x72, 0x6c, 0x64,
}

func TestVariant(t *testing.T) {
	var v testVariant

	err := testDecoder(variantBytes1).DecodeVariant(&v)
	assert.NoError(t, err)
	assert.Equal(t, *v.A, uint64(14595364149838066048))

	err = testDecoder(variantBytes2).DecodeVariant(&v)
	assert.NoError(t, err)
	assert.Equal(t, *v.B, "hello world")
	assert.True(t, v.A == nil)
}

func TestVariantPtr(t *testing.T) {
	var v *testVariant = &testVariant{}

	err := testDecoder(variantBytes1).DecodeVariant(v)
	assert.NoError(t, err)
	assert.Equal(t, *v.A, uint64(14595364149838066048))

	err = testDecoder(variantBytes2).DecodeVariant(v)
	assert.NoError(t, err)
	assert.Equal(t, *v.B, "hello world")
	assert.True(t, (*v).A == nil)

}

// bytes

func TestBytes(t *testing.T) {
	var b []byte
	err := testDecoder([]byte{
		0x03,
		0x01, 0x02, 0x03,
	}).Decode(&b)
	assert.NoError(t, err)
	assert.Equal(t, b, []byte{1, 2, 3})
}

// vector

func TestVector(t *testing.T) {
	var v []uint16
	err := testDecoder([]byte{
		0x03, 0x64, 0x00, 0xe8, 0x03, 0x10, 0x27,
	}).Decode(&v)
	assert.NoError(t, err)
	assert.Equal(t, []uint16{100, 1000, 10000}, v)
}

func TestVectorPtr(t *testing.T) {
	var v *[]*string
	err := testDecoder([]byte{
		0x02, 0x05, 0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x05, 0x77, 0x6f, 0x72, 0x6c, 0x64,
	}).Decode(&v)
	assert.NoError(t, err)
	a, b := "hello", "world"
	assert.Equal(t, *v, []*string{&a, &b})
	err = testDecoder([]byte{
		0x01, 0x05, 0x68, 0x65, 0x6c, 0x6c, 0x6f,
	}).Decode(&v)
	assert.NoError(t, err)
	assert.Equal(t, *v, []*string{&a})
}

// fixed width array

func TestArray(t *testing.T) {
	var v [3]uint16
	err := testDecoder([]byte{
		0x64, 0x00, 0xe8, 0x03, 0x10, 0x27,
	}).Decode(&v)
	assert.NoError(t, err)
	assert.Equal(t, v, [3]uint16{100, 1000, 10000})
}

func TestArrayPtr(t *testing.T) {
	var v [3]*uint16
	err := testDecoder([]byte{
		0x64, 0x00, 0xe8, 0x03, 0x10, 0x27,
	}).Decode(&v)
	assert.NoError(t, err)
	a, b, c := uint16(100), uint16(1000), uint16(10000)
	assert.Equal(t, [3]*uint16{&a, &b, &c}, v)
}

// varints

func TestVaruint(t *testing.T) {
	var v uint
	err := testDecoder([]byte{
		0xce, 0xc2, 0xf1, 0x05,
	}).Decode(&v)
	assert.NoError(t, err)
	assert.Equal(t, uint(12345678), v)
}

func TestVarint(t *testing.T) {
	var v int
	err := testDecoder([]byte{
		0x9b, 0x85, 0xe3, 0x0b,
	}).Decode(&v)
	assert.NoError(t, err)
	assert.Equal(t, int(-12345678), v)
}

// maps

func TestMap(t *testing.T) {
	var m *map[byte]byte
	err := testDecoder([]byte{ // 1=10, 2=20, 3=30
		0x03, 0x01, 0x0a, 0x02, 0x14, 0x03, 0x1e,
	}).Decode(&m)
	assert.NoError(t, err)
	assert.Equal(t, *m, map[byte]byte{1: 10, 2: 20, 3: 30})
	err = testDecoder([]byte{
		0x03, 0x05, 0x0a, 0x06, 0x14, 0x07, 0x1e,
	}).Decode(&m)
	assert.NoError(t, err)
	assert.Equal(t, *m, map[byte]byte{5: 10, 6: 20, 7: 30})
}

// floats

func TestFloat32(t *testing.T) {
	var f float32
	err := testDecoder([]byte{
		0xdb, 0x0f, 0x49, 0x40,
	}).Decode(&f)
	assert.NoError(t, err)
	assert.Equal(t, float32(3.1415927), f)
}

func TestFloat64(t *testing.T) {
	var f float64
	err := testDecoder([]byte{
		0x18, 0x2d, 0x44, 0x54, 0xfb, 0x21, 0x09, 0x40,
	}).Decode(&f)
	assert.NoError(t, err)
	assert.Equal(t, float64(3.141592653589793), f)
}

func TestReuse(t *testing.T) {
	type tst struct {
		A uint64
		B *string
		C []byte
		D map[byte]byte
		E [3]int
		F struct {
			FA int16
			FB uint16
		}
		G *tst   `eosio:"optional"`
		H uint64 `eosio:"optional"`
	}

	str := "hello world"

	v1 := tst{
		A: 14595364149838066048,
		B: &str,
		C: []byte{1, 2, 3},
		D: map[byte]byte{1: 10, 2: 20, 3: 30},
		E: [3]int{1, 2, 3},
		F: struct {
			FA int16
			FB uint16
		}{
			FA: -1,
			FB: 2,
		},
		G: &tst{
			A: 4242,
			B: &str,
			C: []byte{44, 55, 66},
			D: map[byte]byte{2: 22, 3: 33, 4: 44},
			E: [3]int{9, 9, 2},
			F: struct {
				FA int16
				FB uint16
			}{
				FA: 222,
				FB: 0,
			},
		},
		H: 22,
	}

	v1b := bytes.NewBuffer(nil)
	err := abi.NewEncoder(v1b, noopEncodefunc).Encode(v1)
	assert.NoError(t, err)

	str2 := "goodbye"

	v2 := tst{
		A: 5555,
		B: &str2,
		C: []byte{2},
		D: map[byte]byte{99: 255},
		E: [3]int{55, 55, 55},
		F: struct {
			FA int16
			FB uint16
		}{
			FA: -2,
			FB: 42,
		},
	}

	v2b := bytes.NewBuffer(nil)
	err = abi.NewEncoder(v2b, noopEncodefunc).Encode(v2)
	assert.NoError(t, err)

	var vr tst

	err = testDecoder(v1b.Bytes()).Decode(&vr)
	assert.NoError(t, err)
	assert.Equal(t, vr, v1)
	assert.True(t, vr.G != nil)
	assert.Equal(t, len(vr.C), 3)

	err = testDecoder(v2b.Bytes()).Decode(&vr)
	assert.NoError(t, err)
	assert.Equal(t, vr, v2)
	assert.True(t, vr.G == nil)
	assert.Equal(t, len(vr.C), 1)

	err = testDecoder(v1b.Bytes()).Decode(&vr)
	assert.NoError(t, err)
	assert.Equal(t, vr, v1)
}
